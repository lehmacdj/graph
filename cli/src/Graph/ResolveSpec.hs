-- | Additional tests for resolve that require dependencies that would
-- otherwise create circular dependencies
module Graph.ResolveSpec where

import Graph.Create
import Graph.GraphMetadataEditing
import Models.NID
import Models.NormalizedPath
import Models.NormalizedPath.Parse
import Models.ResolvedPath
import MyPrelude
import Utils.Testing

spec_pathResidualsUnresolvedBy :: Spec
spec_pathResidualsUnresolvedBy = do
  let testResiduals :: Text -> Text -> Text -> Spec
      testResiduals pathToCreateStr pathToResidualStr expectedStr =
        it (unpack testName) do
          pathToCreate <-
            unwrapEx "first path must be fully specific"
              . traverseAnchors fullySpecific
              <$> parseForTest "normalized path" pNormalizedPath pathToCreateStr
          let graph = graphFromGraphMetadataEditing $ createNPath pathToCreate
          pathToResidual <-
            parseForTest "normalized path" pNormalizedPath pathToResidualStr
          expected <- parseForTest "normalized path" pNormalizedPath expectedStr
          pathResidualsUnresolvedBy (smallNID 1) graph pathToResidual
            `shouldBe` expected
        where
          testName =
            "residuals of "
              <> pathToResidualStr
              <> " in graph generated by "
              <> pathToCreateStr
              <> " = "
              <> expectedStr

  describe "rooted" do
    testResiduals "[@1<a]>@2" "[a & b]" "[@1<b]>@2"
    testResiduals "[@1<a & @1<b]>@2" "[a]" "%never"
    testResiduals "[@1<a]>@2" "[a]" "%never"
    testResiduals "@1" "[a]" "[@1<a]>@1"
    testResiduals "@1" "[a & b]" "[@1<a & @1<b]>@1"
    testResiduals "@1" "[@<a & @<b]" "[@1<a & @1<b]>@1"
    describe "multiple roots" do
      testResiduals "[[@1<a & @2<b]>@3<c]>@4" "[a & b & c]" "%never"
      testResiduals "[[@1<a & @2<b]>@3<c]>@4" "[@1<a & c]" "[@2<b /@3| c]>@4"

  describe "%never" do
    describe "subtracting from %never always leaves %never" do
      testResiduals "[@1<a]>@2" "%never" "%never"
      testResiduals "@1" "%never" "%never"
    describe "subtracting nothing leaves everything" do
      testResiduals "%never" "[a]" "[a]"
      testResiduals "%never" "@" "@"
      testResiduals "%never" "@[a]" "@[a]"
      testResiduals "%never" "@[a & b /| c]" "@[a & b /| c]"

  describe "pointlike" do
    testResiduals "@1[a]" "@1[a & b]" "@1[b]"
    testResiduals "@1[a]" "@[a & b]" "@1[b]"
    testResiduals "@1[a]" "@1[a]" "%never"
    testResiduals "@1[a]" "%never" "%never"
    testResiduals "@1[a & b]" "@1[a]" "%never"
    testResiduals "@1" "@[a]" "@1[a]"

  describe "sequences" do
    testResiduals "[@1<a /@2| b]>@3" "[a /| b & c]" "[@1<c]>@3"
    testResiduals "[@1<a]>@2" "[a /| b]" "[@2<b]"
    testResiduals "[@1<a]>@2" "[a /| b & c]" "[@2<b & @1<c]"

  describe "wildcard is \"fufilled\" if any specific path matches" do
    testResiduals "[@1<a]>@2" "[*]" "%never"

  describe "inverse" do
    describe "inverse doesn't match forward" do
      testResiduals "[@1<a]>@2" "[~a]" "[~a]"
    testResiduals "[@1<~a]>@2" "[~a]" "%never"
    testResiduals "[@1<~a]>@2" "[~a & ~b]" "[@1<~b]>@2"

  describe "unions" do
    testResiduals "[@1<a]>@2" "[a] + [b]" "[b]"
    testResiduals "[@1<a]>@2" "[a & b] + [c]" "[@1<b]>@2 + [c]"
    testResiduals "[@1<a]>@2" "[a] + [a & b]" "[@1<b]>@2"

  describe "regex is \"fulfilled\" by matching transitions" do
    testResiduals "[@1<apple]>@2" "[regex:'a.*']" "%never"
    testResiduals "[@1<banana]>@2" "[regex:'a.*']" "[@1<banana]>@2"
    testResiduals "[@1<apple]>@2" "[regex:'a.*' & regex:'b.*']" "[@1<regex:'b.*']>@2"
    testResiduals "[@1<apple]>@2" "[regex:'b.*']" "[regex:'b.*']"
